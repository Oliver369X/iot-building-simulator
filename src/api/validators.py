from typing import Dict, Any, List, Optional
from pydantic import BaseModel, Field
from datetime import datetime
import uuid

# --- Device and Device Type Models ---
class DeviceTypeCreate(BaseModel):
    id: Optional[str] = Field(default_factory=lambda: str(uuid.uuid4())) # ID can be optional if auto-generated by DB or pre-defined
    type_name: str = Field(..., description="e.g., 'Termostato', 'Luz LED'")
    properties: Optional[Dict[str, Any]] = Field(None, description='e.g., { "unit": "Â°C", "actions": ["setState", "setValue"] }')

class DeviceTypeUpdate(BaseModel):
    type_name: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None

class DeviceTypeRead(DeviceTypeCreate):
    # id is already in DeviceTypeCreate
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

class DeviceCreate(BaseModel):
    # id is typically assigned by the database, not provided by client on creation
    name: str
    device_type_id: str # Foreign Key to DeviceType
    # room_id will be part of the path, e.g. POST /rooms/{room_id}/devices
    state: Optional[Dict[str, Any]] = Field(None, description='e.g., { "power": "OFF", "brightness": 80, "target_temp": 21 }')
    is_active: Optional[bool] = True

class DeviceUpdate(BaseModel):
    name: Optional[str] = None
    device_type_id: Optional[str] = None
    room_id: Optional[str] = None # To move device to a different room
    state: Optional[Dict[str, Any]] = None
    is_active: Optional[bool] = None

class DeviceRead(DeviceCreate):
    id: str
    room_id: str # Added room_id as it's part of the model and useful for reads
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

# --- Room Models ---
class RoomCreate(BaseModel):
    name: str
    # floor_id will be part of the path, e.g. POST /floors/{floor_id}/rooms

class RoomUpdate(BaseModel):
    name: Optional[str] = None
    is_simulating: Optional[bool] = None
    # floor_id: Optional[str] = None # To move room to a different floor (more complex)

class RoomRead(RoomCreate):
    id: str
    floor_id: str # Added floor_id as it's part of the model and useful for reads
    is_simulating: bool # Added for simulation control
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

# --- Floor Models ---
class FloorCreate(BaseModel):
    floor_number: int
    plan_url: Optional[str] = None
    # building_id will be part of the path, e.g. POST /buildings/{building_id}/floors

class FloorUpdate(BaseModel):
    floor_number: Optional[int] = None
    plan_url: Optional[str] = None
    is_simulating: Optional[bool] = None
    # building_id: Optional[str] = None # To move floor to a different building (more complex)

class FloorRead(FloorCreate):
    id: str
    building_id: str # Added building_id as it's part of the model and useful for reads
    is_simulating: bool # Added for simulation control
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

# --- Building Models ---
class BuildingCreate(BaseModel):
    name: str
    address: Optional[str] = None
    geolocation: Optional[Dict[str, float]] = Field(None, description='e.g., {"latitude": 40.7128, "longitude": -74.0060}')
    # Nested creation of floors, rooms, devices can be complex.
    # The new spec implies individual CRUD endpoints.
    # For simplicity, we'll assume buildings are created, then floors, then rooms, then devices.

class BuildingRead(BuildingCreate): # Inherits fields from BuildingCreate
    id: str
    is_simulating: bool # Added for simulation control
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True # To allow direct creation from SQLAlchemy model instance

class BuildingUpdate(BaseModel):
    name: Optional[str] = None
    address: Optional[str] = None
    geolocation: Optional[Dict[str, float]] = None
    is_simulating: Optional[bool] = None

# --- Device Control and Scheduling ---
class DeviceAction(BaseModel):
    type: str = Field(..., description='e.g., "setState"')
    payload: Dict[str, Any] = Field(..., description='e.g., { "power": "ON", "brightness": 100 }')

class DeviceScheduleCreate(BaseModel):
    # device_id will be part of the path
    cron_expression: str = Field(..., description="e.g., '0 18 * * *'")
    action: Dict[str, Any] = Field(..., description='e.g., { "type": "setState", "payload": { "power": "ON" } }')
    is_enabled: Optional[bool] = True

class DeviceScheduleUpdate(BaseModel):
    cron_expression: Optional[str] = None
    action: Optional[Dict[str, Any]] = None
    is_enabled: Optional[bool] = None

class DeviceScheduleRead(DeviceScheduleCreate):
    id: str
    device_id: str # Added device_id as it's part of the model and useful for reads
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

# --- Alarm Models ---
class AlarmCreate(BaseModel): # Used by the simulation engine, not directly by an API endpoint for creation
    device_id: str
    severity: str = Field(..., description="e.g., 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'")
    description: Optional[str] = None
    # status is typically 'NEW' on creation, triggered_at is set by DB

class AlarmRead(BaseModel):
    id: str
    device_id: str
    severity: str
    status: str
    description: Optional[str] = None
    triggered_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

class AlarmUpdate(BaseModel): # For operations like ACK
    status: Optional[str] = Field(None, description="e.g., 'ACK', 'RESOLVED'")
    # Other fields like severity or description could be updatable if needed

# For POST /alarms/{id}/ack, no body is specified, so no Pydantic model needed for request.
# For GET /alarms, query parameters will be handled directly in endpoint.

# --- Telemetry Models ---
class TelemetryDataPoint(BaseModel):
    timestamp: datetime
    value: Any # Can be float, int, string, bool depending on the telemetry key
    key: str # e.g., 'temperature', 'power_consumption'

class TelemetryResponse(BaseModel):
    device_id: str
    data_points: List[TelemetryDataPoint]
    # Potentially add aggregation info if provided by the query
    aggregation_interval: Optional[str] = None

# --- Old Models (to be removed or re-evaluated) ---
# class DeviceStatusUpdate(BaseModel):
#     status: str = Field(..., pattern="^(active|inactive)$")
#     reading: Optional[float] = None
#     timestamp: Optional[datetime] = None

# class SimulationStart(BaseModel):
#     building_id: str
#     duration: Optional[int] = Field(default=3600, ge=1)
#     events_per_second: Optional[float] = Field(default=1.0, gt=0)
